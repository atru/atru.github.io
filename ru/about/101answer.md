---
title: Квалификационный тест 101media.ru
layout: page
lang: ru
lang_view: false
---


HTML и CSS
=====================

1. [Вёрстка 1][html1]
1. [Вёрстка 2][html2]
1. *Есть ссылка, при нажатии на которую пользователю в новом окне должна отображаться схема проезда.*

  ```html
  <a href="#" onclick="popup('/map/', 300, 300, 'map'); return false;">Схема проезда</a>
  ```
  *Расскажите, почему не стоит использовать ссылки подобным образом? Приведите аргументы. Каким образом можно исправить ситуацию.*

  1. У пользователей без включенного javascript (или в некоторых браузерах с плохой поддержкой js) ссылка не сработает
  1. При наведении на ссылку неизвестен адрес, куда пользователь попадёт; такую ссылку нельзя открыть средней кнопкой мыши (либо в контекстном меню «Открыть в новой вкладке»)
  1. Поисковые роботы не смогут выполнить переход по такой ссылке. В случае схемы проезда это может быть не важно, но в других случаях ресурс останется не проиндексрован

  Решить можно добавлением ссылки в атрибут: `href="/map/"`, а также атрибута `target="map"`, чтобы ссылка открылась в новом окне.

  В результате пользователи с включенным javascript увидят плоды работы скрипта (возможно, изначально подразумевалась всплывающая форма, а не новое окно браузера &mdash; `return false;` не позволит открыть новую вкладку); пользователи без javascript попадут в новое окно, где будет отображена схема проезда.

JavaScript
=====================

1. [Array.prototype.find()][javascript1]
1. [Первый вариант][javascript2]. [Второй вариант][javascript3]

PHP
=====================

1. *Написать результат и описать последовательность выполнения кода интерпретатором.*

  ```php
  <?php
  $i = 5;
  echo −−$i + $i++;
  ?>
  ```
  Результат: 8.

  Команда `--$i` выполнится перед `echo`, получится `echo 4 + 4; //8` . Команда `$i++` выполнится после, но никто об этом не узнает.

1. *Написать результат и состояние массива на каждом шаге выполнения программы.*

  ```php
  <?php
  $arr = array(1, 3, 5, 7); //Array ( [0] => 1 [1] => 3 [2] => 5 [3] => 7)
  echo array_pop($arr); //Array ( [0] => 1 [1] => 3 [2] => 5), выведется текст "7"
  echo array_shift($arr); //Array ( [0] => 3 [1] => 5), выведется текст "1"
  echo $arr[0]; //выведется текст "3"
  echo $arr[2]; //ничто не выведется
  ?>
  ```

1.  *Каков будет результат работы этой программы. Напишите последовательность вызова конструкторов.*

  ```php
  <?php
  abstract class Foo_A {
    public $var;
    public function __construct()
    {
      $this->var = 10;  //var = 10
    }
  }
  class Foo_B extends Foo_A {
    public function __construct()
    {
      parent::__construct();  //var = 10
      $this->var = 20;  //var = 20
    }
  }
  class Foo_C extends Foo_B {
    public function __construct()
    {
      $this->var = 30;  //var = 30
      parent::__construct();   //var = 10, потом var = 20
    }
  }

  $Foo = new Foo_C();
  echo $Foo->var; // 20
?>
```

1. *Что такое «интерфейс» в ООП. Зачем они нужны?*

  Интерфейс &mdash; это т.н. чистый абстрактный класс, содержащий только абстрактные методы. Определённый класс может наследовать исключительно один абстрактный класс («являться»), однако реализовывать несколько интерфейсов («уметь делать»). Это «умение делать» может распространяться на различные по своей природе объекты: человек и машина могут быть каждый по&ndash;своему быть «сравниваемы» с другими людьми/машинами, «сортируемы», уметь «считать свой КПД» (человек &mdash; по выполненной работе, машина по пройденному пути) и т.п. При этом человек унаследовал класс «Млекопитающее», а машина &mdash; «СредствоПередвижения», которые никогда не слышали про сравниваемость, сортируемость, КПД.

  Интерфейсы нужны для универсализации в системе (полиморфизм), уменьшения связности компонентов системы, в юнит-тестировании.

1. *Шаблоны проектирования. Что это такое? Описать несколько.*

  Шаблоны проектирования &mdash; систематизированный набор конструкций, позволяющий решить часто повторяющиеся задачи при проектировании систем.

  Основные шаблоны проектирования классов/объектов обычно разделяют на три типа:  
    * порождающие
    * поведенческие
    * структурные

  Пример порождающего шаблона: «Строитель». Изолирует создание объекта от его представления, позволяя при одинаковом процессе конструирования получать различные объекты. Для базового объекта строительства создаётся абстрактный строитель. Различные конкретные реализации строителя позволяют изменять детали объекта строительства, при этом вызов изменений происходит одинаково, достаточно указать конкретного строителя. К недостаткам можно отнести каскадное изменение всех строителей при изменении объекта строительства.

  Пример поведенческого шаблона: «Наблюдатель». Позволяет описать зависимость «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все привязанные к нему объекты оповещаются об этом событии. При этом каждый изменяемый объект хранит набор своих наблюдателей. Применяется в случае неизвестного количества наблюдателей (изменяется в ходе работы).

  Пример структурного шаблона: «Компоновщик». Объединяет объекты в древовидную структуру для представления их иерархии. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково. Классы одновременно могут состоять из примитивных и сложных объектов, что упрощает архитектуру клиента, делает процесс добавления новых видов объекта более простым.

SQL
=====================

1. *Запрос, который выведет список должностей, на которых числится более 10 сотрудников.*

  ```sql
  SELECT post
      FROM employers
      GROUP BY post
      HAVING COUNT(employee)>10
  ```

1. *Рассказать, как вы будете хранить и получать связанные N:N сущности и почему. Приведите примеры запросов.*

  Связанные многие&ndash;ко&ndash;многим сущности имеют каждая свой суррогатный ключ:

  `A: A_KEY (PK)`,

  `B: B_KEY (PK)`.

  Связь осуществляется дополнительной сущностью, т.н. таблицей смежности, где идут пары ключей

  `C: A_KEY(FK) B_KEY(FK)`

  Пример запроса:

    ```sql
    SELECT A.*, B.*
        FROM A
            JOIN C ON (A.A_KEY = C.A_KEY)
            JOIN B ON (B.B_KEY = C.B_KEY)
        WHERE B.EMP=101
    ```




[html1]: http://jsfiddle.net/n3CDs/
[html2]: http://jsfiddle.net/k3pSB/
[javascript1]: http://jsfiddle.net/ZCj3N/
[javascript2]: http://jsfiddle.net/AGA7x/
[javascript3]: http://jsfiddle.net/4S6GZ/
